---
title: "Introduction to AzureKeyVault"
author: Hong Ooi
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to AzureKeyVault}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{utf8}
---

AzureKeyVault is a package for working with [Azure Key Vault](https://azure.microsoft.com/services/key-vault/), a secure storage facility for secrets, encryption keys, authentication certificates, and storage account access keys. It provides both a client interface, to access the contents of the vault, and a Resource Manager interface for administering the Key Vault itself.

You can install the development version of the package from GitHub:

```r
devtools::install_github("cloudyr/AzureKeyVault")
```

## Resource Manager interface

AzureKeyVault extends the [AzureRMR](https://github.com/cloudyr/AzureRMR) package to handle key vaults. In addition to creating and deleting vaults, it provides methods to manage access policies for user and service principals.

```r
# create a key vault
rg <- AzureRMR::get_azure_login()$
    get_subscription("sub_id")$
    get_resource_group("rgname")
kv <- rg$create_key_vault("mykeyvault")

# list current principals (by default includes logged-in user)
kv$list_principals()

# get details for a service principal
svc <- AzureGraph::get_graph_login()$
    get_service_principal("app_id")

# give the service principal read-only access to vault keys and secrets
kv$add_principal(svc,
    key_permissions=c("get", "list", "backup"),
    secret_permissions=c("get", "list", "backup"),
    certificate_permissions=NULL,
    storage_permissions=NULL)
```

## Client interface

The client interface is R6-based. To access the vault, instantiate a new object of class `key_vault`. This object includes component objects for interacting with keys, secrets, certificates and managed storage accounts.


```r
vault <- key_vault$new("https://mykeyvault.vault.azure.net")

# can also be done from the ARM resource object
vault <- kv$get_endpoint()
```

### Keys

The `keys` component provides methods for working with encryption keys:
- `create`: Create a new key, or a new version of an existing key.
- `import`: Import a key from a PEM file.
- `get`: Retrieve an existing key.
- `list`: List all keys in the vault.
- `backup`: Return a base64-encoded blob representing the key.
- `restore`: Use a blob obtained by the `backup` method to restore a key.

In turn, an individual key is represented by an object of class `stored_key`. This has the following methods:
- `list_versions`: List the available versions for this key.
- `set_version`: Set the version of the key to use. The default is to use the most recently created version.
- `encrypt`: Encrypt a character string or raw vector, producing a ciphertext string.
- `decrypt`: Decrypt a ciphertext string, producing either a character string or raw vector. The inverse operation of `encrypt`.
- `sign`: Sign a hashed digest.
- `verify`: Verify the signature of a hash. The inverse operation of `sign`.
- `wrap`: Wrap a symmetric key.
- `unwrap`: Unwrap a wrapped key. The inverse operation of `wrap`.

The key object contains the public key component in the `key` field, as a parsed JSON web key. Note that Azure Key Vault does not provide access to the _private_ key component.

```r
# create a new RSA key with 4096-bit key size
vault$keys$create("newkey", properties=key_properties(type="RSA", rsa_key_size=4096))

# encrypting and decrypting
key <- vault$keys$get("newkey")
plaintext <- "super secret"
ciphertext <- key$encrypt(plaintext)
decrypted_text <- key$decrypt(ciphertext, as_raw=FALSE)
plaintext == decrypted_text
#> [1] TRUE

# exporting the public key component, using the jose and openssl packages
pubkey <- key$key
openssl::write_pem(jose::read_jwk(pubkey), "pubkey.pem")

# importing a key generated by openssl
sslkey <- openssl::rsa_keygen()
vault$keys$import("sslkey", sslkey)

# importing a key from a file
openssl::write_pem(sslkey, "sslkey.pem")
vault$keys$import("sslkeyfromfile", "sslkey.pem")
```

### Secrets

The `secrets` component provides methods for working with generic secrets:
- `create`: Create a new secret, or a new version of an existing secret.
- `get`: Retrieve an existing secret.
- `list`: List all secrets in the vault.
- `backup`: Return a base64-encoded blob representing the secret.
- `restore`: Use a blob obtained by the `backup` method to restore a secret.

An individual secret is represented by an object of class `stored_secret`. Unlike a key, a secret is essentially just data, so the object does not have any operations associated with it. It has the following methods for managing secret versions:
- `list_versions`: List the available versions for this secret.
- `set_version`: Set the version of the secret to use. The default is to use the most recently created version.

The secret itself is in the `value` field of the object.

```r
# create a new secret
vault$secrets$create("newsecret", "hidden text")
secret <- vault$secrets$get("newsecret")
secret$value
#> [1] "hidden text"
```

### Certificates

The `certificates` component provides methods for working with authentication certificates:
- `create`: Create a new certificate, or a new version of an existing certificate.
- `import`: Import a certificate from a PFX file.
- `get`: Retrieve an existing certificate.
- `list`: List all certificates in the vault.
- `backup`: Return a base64-encoded blob representing the certificate.
- `restore`: Use a blob obtained by the `backup` method to restore a certificate.

An individual certificate is represented by an object of class `stored_certificate`. This has the following methods:
- `list_versions`: List the available versions for this key.
- `set_version`: Set the version of the key to use. The default is to use the most recently created version.
- `export`: Encrypt a character string or raw vector, producing a ciphertext string.
- `set_policy`: Decrypt a ciphertext string, producing either a character string or raw vector. The inverse operation of 


```r
# create a new self-signed certificate (will also create an associated key and secret)
cert <- vault$certificates$create("newcert",
    subject="CN=example.com",
    x509=cert_x509_properties(dns_names="example.com"))

# export the certificate as a PEM file
cert$export("newcert.pem")

# import a certificate from a PFX file
vault$certificates$import("importedcert", "mycert.pfx")
```


### Storage accounts

```r
# add a managed storage account
stor <- rg$get_resource(type="Microsoft.Storage/storageAccounts", name="mystorage")
vault$storage$add("mystorage", stor, "key1")
```

