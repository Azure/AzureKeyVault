% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/keys.R, R/stored_key.R
\docType{class}
\name{keys}
\alias{keys}
\title{Encryption keys in Key Vault}
\description{
This class represents the collection of encryption keys stored in a vault. It provides methods for managing keys, including creating, importing and deleting keys, and doing backups and restores. For operations with a specific key, see \link{key}.

This class represents an encryption keys stored in a vault. It provides methods for carrying out operations, including encryption and decryption, signing and verification, and wrapping and unwrapping.
}
\section{Methods}{

This class provides the following methods:\preformatted{create(name, properties=key_properties(), key_ops=NULL,
       attributes=vault_object_attrs(), ...)
import(name, key, hardware=FALSE,
       attributes=vault_object_attrs(), ...)
get(name)
delete(name, confirm=TRUE)
list()
backup(name)
restore(backup)
}


This class provides the following methods:\preformatted{encrypt(plaintext, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"))
decrypt(ciphertext, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"), as_raw=TRUE)
sign(digest,
     algorithm=c("PS256", "PS384", "PS512", "RS256", "RS384", "RS512",
                 "ES256", "ES256K", "ES384", "ES512"))
verify(signature, digest,
       algorithm=c("PS256", "PS384", "PS512", "RS256", "RS384", "RS512",
                   "ES256", "ES256K", "ES384", "ES512"))
wrap(value, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"))
unwrap(value, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"), as_raw=TRUE)

update_attributes(attributes=vault_object_attrs(), ...)
list_versions()
set_version(version=NULL)
delete(confirm=TRUE)
}
}

\section{Arguments}{

\itemize{
\item \code{name}: The name of the key.
\item \code{properties}: For \code{create}, a list of properties for the key. A convenient way to provide this is via the \link{key_properties} helper function.
\item \code{key_ops}: A character vector of operations that the key supports. The possible operations are "encrypt", "decrypt", "sign", "verify", "wrapkey" and "unwrapkey". See \link{key} for more information.
\item \code{attributes}: Optional attributes for the key, such as the expiry date and activation date. A convenient way to provide this is via the \link{vault_object_attrs} helper function.
\item \code{key}: For \code{import}, the key to import. This can be the name of a PEM file, a JSON web key (JWK) string, or a key object generated by the openssl package. See the examples below.
\item \code{hardware}: For \code{import}, whether to import this key as a hardware key (HSM). Only supported for a premium key vault.
\item \code{...}: For \code{create} and \code{import}, other named arguments which will be treated as tags.
\item \code{backup}: For \code{restore}, a string representing the backup blob for a key.
}


\itemize{
\item \code{plaintext}: For \code{encrypt}, the plaintext to encrypt.
\item \code{ciphertext}: For \code{decrypt}, the ciphertext to decrypt.
\item \code{digest}: For \code{sign}, a generated hash to sign. For \code{verify}, the digest to verify for authenticity.
\item \code{signature}: For \code{verify}, a signature to verify for authenticity.
\item \code{value}: For \code{wrap}, a symmetric key to be wrapped; for \code{unwrap}, the value to be unwrapped to obtain the symmetric key.
\item \code{as_raw}: For \code{decrypt} and \code{unwrap}, whether to return a character vector or a raw vector (the default).
\item \code{algorithm}: The algorithm to use for each operation. Note that the operation must be compatible with the key type.
\item \code{attributes}: For \code{update_attributes}, the new attributes for the object, such as the expiry date and activation date. A convenient way to provide this is via the \link{vault_object_attrs} helper function.
\item \code{...}: For \code{update_attributes}, additional key-specific properties to update. See \link{keys}.
\item \code{version}: For \code{set_version}, the version ID or NULL for the current version.
\item \code{confirm}: For \code{delete}, whether to ask for confirmation before deleting the key.
}
}

\section{Value}{

For \code{get}, \code{create} and \code{import}, an object of class \code{stored_key}, representing the key itself. This has methods for carrying out the operations given by the \code{key_ops} argument.

For \code{list}, a vector of key names.

For \code{backup}, a string representing the backup blob for a key. If the key has multiple versions, the blob will contain all versions.


For the key operations, a raw vector (for \code{decrypt} and \code{unwrap}, if \code{as_raw=TRUE}) or character vector.

For \code{list}, a vector of key version IDs.

For \code{set_version}, the key object with the updated version.
}

\section{Details}{

The operations supported by a key will be those given by the \code{key_ops} argument when the key was created. By default, a new key supports all the operations listed above: encrypt/decrypt, sign/verify, and wrap/unwrap.

A key can have multiple \emph{versions}, which are automatically generated when a key is created with the same name as an existing key. By default, the most recent (current) version is used for key operations; use \code{list_versions} and \code{set_version} to change the version.
}

\examples{
\dontrun{

vault <- key_vault$new("mykeyvault")

vault$keys$create("mynewkey")
vault$keys$create("myRSAkey", key_properties(type="RSA", rsa_key_size=4096))
vault$keys$create("myECkey", key_properties(type="EC", ec_curve="P-384"))

vault$keys$list()
vault$keys$get("mynewkey")

# specifying an expiry date
today <- Sys.date()
vault$keys$create("mynewkey", attributes=vault_object_attrs(expiry_date=today+365))

# setting management tags
vault$keys$create("mynewkey", tag1="a value", othertag="another value")

# importing a key from a PEM file
vault$keys$import("importedkey1", "myprivatekey.pem")

# importing a key generated by OpenSSL
vault$keys$import("importedkey2", openssl::rsa_keygen())

# importing a JWK (which is a JSON string)
key <- openssl::read_key("myprivatekey.pem")
jwk <- jose::write_jwk(key)
vault$keys$import("importedkey3", jwk)

# backup and restore a key
bak <- vault$keys$backup("mynewkey")
vault$keys$delete("mynewkey", confirm=FALSE)
vault$keys$restore(bak)

}
\dontrun{

vault <- key_vault$new("mykeyvault")

vault$keys$create("mynewkey")
# new version of an existing key
vault$keys$create("mynewkey", key_properties(type="RSA", rsa_key_size=4096))

key <- vault$keys$get("mynewkey")
vers <- key$list_versions()
key$set_version(vers[2])

plaintext <- "some secret text"

ciphertext <- key$encrypt(plaintext)
decrypted <- key$decrypt(ciphertext, as_raw=FALSE)
decrypted == plaintext  # TRUE

dig <- digest::digest(plaintext, "sha256", raw=TRUE)
sig <- key$sign(dig)
key$verify(sig, dig)  # TRUE

wraptext <- key$wrap(plaintext)
unwrap_text <- key$unwrap(wraptext, as_raw=FALSE)
plaintext == unwrap_text  # TRUE

}
}
\seealso{
\link{key}, \link{key_properties}, \link{vault_object_attrs}

\href{https://docs.microsoft.com/en-us/azure/key-vault/}{Azure Key Vault documentation},
\href{https://docs.microsoft.com/en-us/rest/api/keyvault}{Azure Key Vault API reference}

\link{keys}

\href{https://docs.microsoft.com/en-us/azure/key-vault/}{Azure Key Vault documentation},
\href{https://docs.microsoft.com/en-us/rest/api/keyvault}{Azure Key Vault API reference}
}
